<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>无所不为轩</title><link href="feeds/" rel="alternate"></link><link href="feeds/feeds/text.atom.xml" rel="self"></link><id>feeds/</id><updated>2013-07-02T01:33:26+08:00</updated><entry><title>怪想法—关于缓解请求与应答之间的“交流”障碍</title><link href="feeds/guai-xiang-fa-guan-yu-huan-jie-qing-qiu-yu-ying-da-zhi-jian-de-jiao-liu-zhang-ai.html" rel="alternate"></link><updated>2013-07-02T01:33:26+08:00</updated><author><name>cupen</name></author><id>tag:feeds,2013-07-02:guai-xiang-fa-guan-yu-huan-jie-qing-qiu-yu-ying-da-zhi-jian-de-jiao-liu-zhang-ai.html</id><summary type="html">&lt;p&gt;本想法是应用在如HTTP这样单向“请求-应答”式的数据交换方式下。
先描述一个普通的web应用的运作( 不要在意细节 ;b  )&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Client 向Server发出请求;&lt;/li&gt;
&lt;li&gt;Server 收到请求处理之，然后发出应答;&lt;/li&gt;
&lt;li&gt;Client 收到应答;&lt;/li&gt;
&lt;li&gt;Client 分析应答，并产生对应的“行为”;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如上，普通web应用的运作过程就是不断地重复以上步骤。
这有点像我们人与人之间对话的过程，我将之拟人化也毫不违和：Client向Server提出问题，再收到Server的回答，
然后根据Server的回答来行动。之后Client继续向Server提问…… 往复循环。
但是区区程序员无法让Client与Server如人一样智能地对话(扯AI我就暴露了，赶紧扯回来)。他们只能为Client和
Server立一个约定，这个约定定义了Server应答过来的各项数据的含义，Server按约定来提供数据，Client按约定来
“理解”数据。至于数据格式，那得另起话题了。&lt;/p&gt;
&lt;blockquote&gt;
（题外话:二进制如 Msgpack,Protocol buffers等等，可读文本如 JSON,XML,甚至是脚本语言源码（如JavaScript））&lt;/blockquote&gt;
&lt;p&gt;如此，项目一开始程序员们分分钟就约定好了数据的含义：“A接口返回数据dataA，B接口返回数据dataB……”。Client
和Server轻松快乐地进行着“你问我答”，程序员们便安心回家睡觉觉了，皆大欢喜。&lt;/p&gt;
&lt;p&gt;但是好景不长。后续的新增、修改需求导致Server提供的接口大量地增改，甚至需要在个别接口里提供已经由其它接
口提供过的数据，但Client依然要为不同接口返回的数据分别做处理，这严重增加了程序员们的工作量。更惨烈的是，
根据约定，Server的x接口提供XX数据，而当Server无法提供XX数据时就需要做其它应答了。就好比Client问Server：“现在几点钟？
”，常规情况下Server答曰：“22:43:00”，意外情况下答曰“我没带表，你可以问其他Server。”，或者更意外的情况：“我
已经死掉了，现在你听到的是我十年前的录音。”&lt;/p&gt;
&lt;p&gt;对人来说，这种情况实在小case. 但在程序上你得新增对数据含义的约定以区分各种意外情况。这还不算，由于每个
Server提供的接口里都可能有多个逻辑分支，那么每个接口都要为各种逻辑分支新增数据含义的约定。至此，程序员们
应该会感觉到Client与Server之间“交流”有点困难了，这时候如果还不反思这种毫无设计的做法的话，估计是打算玩命
地领加班费了。&lt;/p&gt;
&lt;p&gt;当然，程序员们又不是猪，英明的他们决定要认认真真地重新设计。
先理一下前面碰到两个巨坑：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;数据含义的约定无法复用或极难复用。想象一下，如果多个接口返回的数据中都包含了dataX，如何避免重复地约定dataX的数据含义？&lt;/li&gt;
&lt;li&gt;数据含义的约定与提供数据的Server接口绑死了，于是Server接口必须返回约定好的数据，否则霹雳啪啪轰隆咔咔出事故扣工资卷铺盖。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好的 我的怪想法总算可以粉墨登场了：&lt;/p&gt;
&lt;p&gt;我们给每个数据集合加入唯一标识，而数据含义则围绕着唯一标识来进行约定，Client根据这个唯一标识来处理对应的数据
集合。如此，每个数据集合都通过唯一标识来区分，只要Server接口返回了自带唯一标识的数据集合，Client便能按唯一标
识来“理解”，对于表示意外情况的数据含义也只需要约定一次即可。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;举个解决坑1的例子，我们将{气温、天气、风力、地点、标识}这个数据集合中的标识定义为“天气预报”，那么对于任何Sever接口返回的带有“天气信息”标识的数据集合，Client都按“天气信息”的约定来处理这个数据集合，丝毫不用理会这个“天气信息”是来自哪个Server接口，而这个“天气信息”的数据含义只需约定一次。&lt;/li&gt;
&lt;li&gt;举个解决坑2的例子，假设Client向Server请求“天气信息”，而这时候Server可能会碰到多种情况：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;生成“天气信息”的操作未完成，可以返回标识为“重复之前的请求”的数据。&lt;/li&gt;
&lt;li&gt;Client的Session信息过期了，可以返回标识为“重新登录”的数据。&lt;/li&gt;
&lt;li&gt;Server停服中，可以返回标识为“停服”的数据(包含一条文字公告更好)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;未完待续……&lt;/div&gt;
&lt;div class="line"&gt;欲知后事如何，请再听下个月分解。&lt;/div&gt;
&lt;/div&gt;
</summary><category term="http"></category><category term="cs"></category></entry><entry><title>小用xdebug</title><link href="feeds/xiao-yong-xdebug.html" rel="alternate"></link><updated>2013-05-17T00:12:41+08:00</updated><author><name>cupen</name></author><id>tag:feeds,2013-05-17:xiao-yong-xdebug.html</id><summary type="html">&lt;p&gt;经常忘了xdebug的配置，老查文档慢的要死，挑出常用的配置记录一下。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;关于IDE和一些其它周边工具以后再补充吧。&lt;/div&gt;
&lt;div class="line"&gt;超详细的使用实例: &lt;a class="reference external" href="http://xdebug.org/docs/all"&gt;http://xdebug.org/docs/all&lt;/a&gt;&lt;/div&gt;
&lt;div class="line"&gt;超详细的配置说明: &lt;a class="reference external" href="http://xdebug.org/docs/all_settings"&gt;http://xdebug.org/docs/all_settings&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[XDebug]&lt;/span&gt;
&lt;span class="c1"&gt;; 所有可配置项见 http://xdebug.org/docs/all_settings&lt;/span&gt;
&lt;span class="na"&gt;zend_extension&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/local/app/bin/php/ext/php_xdebug.so&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;; 分析信息用追加方式写入文件，&lt;/span&gt;
&lt;span class="c1"&gt;; 使用触发的方式，不需要每次运行都分析。 在参数或者cookie里加入 XDEBUG_PROFILE&lt;/span&gt;
&lt;span class="na"&gt;xdebug.profiler_append&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;xdebug.profiler_enable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="na"&gt;xdebug.profiler_enable_trigger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;

&lt;span class="c1"&gt;; 配置文件存放位置 %s表示脚本名（带路径）&lt;/span&gt;
&lt;span class="c1"&gt;; 文件名含义同trace_output_name, 见：http://xdebug.org/docs/all_settings#trace_output_name&lt;/span&gt;
&lt;span class="na"&gt;xdebug.profiler_output_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/local/app/bin/php/trace/profiler/&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;xdebug.profiler_output_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;profiler.%s.txt&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;; 远程调试相关的设置&lt;/span&gt;
&lt;span class="na"&gt;xdebug.remote_enable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;on&lt;/span&gt;
&lt;span class="na"&gt;xdebug.remote_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;dbgp&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;xdebug.remote_host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;xdebug.remote_prot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;9000&lt;/span&gt;

&lt;span class="c1"&gt;; trace文件的存放&lt;/span&gt;
&lt;span class="c1"&gt;; 文件名含义见 http://xdebug.org/docs/all_settings#trace_output_name&lt;/span&gt;
&lt;span class="na"&gt;xdebug.trace_output_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/local/app/bin/php/trace/trace/&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;xdebug.trace_output_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;trace.%s&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;; trace信息是否按是否以追加方式写入到文件（为啥不是apend？）&lt;/span&gt;
&lt;span class="c1"&gt;; 0 表示覆盖式写入文件&lt;/span&gt;
&lt;span class="c1"&gt;; 1 表示追加式写入文件&lt;/span&gt;
&lt;span class="na"&gt;xdebug.trace_options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;0&lt;/span&gt;

&lt;span class="c1"&gt;; 不需要自动trace,除非你希望每次执行都会trace(与auto_trace互斥)&lt;/span&gt;
    &lt;span class="c1"&gt;; 触发trace的方式: 在参数或cookie里加入XDEBUG_TRACE&lt;/span&gt;
&lt;span class="na"&gt;xdebug.auto_trace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="na"&gt;xdebug.trace_enable_trigger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;


&lt;span class="c1"&gt;; 收集变量的赋值&lt;/span&gt;
&lt;span class="na"&gt;xdebug.collect_assignments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;

&lt;span class="c1"&gt;; 收集-包含语句&lt;/span&gt;
&lt;span class="c1"&gt;; 使用 include(), include_once(), require() require_once()引入的脚本名会被记录下来&lt;/span&gt;
&lt;span class="na"&gt;xdebug.collect_includes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;

&lt;span class="c1"&gt;; 收集函数的参数&lt;/span&gt;
&lt;span class="c1"&gt;; 1 表示仅记录参数类型和长度 (f.e. string(6), array(8))&lt;/span&gt;
&lt;span class="c1"&gt;; 2 表示仅记录参数类型和长度 ，以及简略信息。 （好吧，我懒得用这个参数，不知具体效果）&lt;/span&gt;
&lt;span class="c1"&gt;; 3 表示仅记录参数的内容 至于记录的限度，得看关于变量显示限度的设置&lt;/span&gt;
&lt;span class="c1"&gt;;           xdebug.var_display_max_children,&lt;/span&gt;
&lt;span class="c1"&gt;;           xdebug.var_display_max_data&lt;/span&gt;
&lt;span class="c1"&gt;;           xdebug.var_display_max_depth.&lt;/span&gt;
&lt;span class="c1"&gt;; 4 表示记录参数的名字和全部内容，不受变量显示限度设置的影响&lt;/span&gt;
&lt;span class="na"&gt;xdebug.collect_params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;4&lt;/span&gt;

&lt;span class="c1"&gt;; 收集函数的返回值&lt;/span&gt;
&lt;span class="na"&gt;xdebug.collect_return&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;1&lt;/span&gt;

&lt;span class="c1"&gt;; trace信息格式&lt;/span&gt;
&lt;span class="c1"&gt;; 0 给人看的格式（默认值）&lt;/span&gt;
&lt;span class="c1"&gt;; 1 给程序解析用的格式 （给其它工具设计的）&lt;/span&gt;
&lt;span class="c1"&gt;; 2 html文本（信息量太少了）&lt;/span&gt;
&lt;span class="na"&gt;xdebug.trace_format&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><category term="xdebug"></category><category term="php"></category></entry></feed>